# Havannah Winning-Condition Algorithms

This project represents Havannah positions with a square `dim × dim` array where `dim = 2 × layers − 1`. Each entry stores:

- `0` – empty hex
- `1` – player 1 stone
- `2` – player 2 stone
- `3` – off-board filler used to keep the array rectangular

Only coordinates that belong to the geometric hexagon are treated as playable. Helper routines in `helper.py` expose the logic that the AI and UI rely on to validate moves and detect the three Havannah winning structures: **ring**, **bridge**, and **fork**.

## Coordinate System & Neighbourhood

- Board indices are `(row, column)` with the origin at the upper-left corner.
- `get_neighbours(dim, vertex)` returns up to eight axial neighbours that share an edge with the hex. The function mirrors the Python board layout by switching the diagonal offsets when we are to the left or right of the centre column (`siz = dim // 2`).
- `is_valid(i, j, dim)` guards against indices that fall outside the square container.

These two routines form the basis for all traversals.

## Reachability via BFS

`bfs_reachable(board_mask, start)` performs a breadth-first search starting from `start` across the boolean `board_mask` that marks the current player’s stones. The function:

1. enqueues `start` and records it in a `visited` set,
2. repeatedly dequeues a hex, walks through all axial neighbours, and
3. enqueues any neighbour that is both on-board and also occupied by the current player.

The result is the connected component (in axial adjacency) that contains the triggering move. Both fork and bridge detection are powered by this BFS.

## Ring Detection

`check_ring(board_mask, move)` implements a directed DFS that searches for a simple loop containing the latest stone:

1. Abort early unless the move touches at least two already-occupied neighbours (a necessary condition for a ring).
2. Enumerate four “forward” directions (`up`, `top-left`, `bottom-left`, `down`) and push any occupied neighbour reachable in those directions on to an exploration frontier. Directions carry state so the DFS can avoid U-turns.
3. While the frontier is non-empty, pick the next `(hex, direction)` pair and continue in the three directions returned by `three_forward_moves(direction)`. The helper `move_coordinates(direction, half)` converts each direction into a `(Δrow, Δcol)` step adjusted for whether the move lies left, on, or right of the middle column.
4. If we revisit the starting coordinate after taking at least five steps, the code declares a ring. The implementation marks `(hex, direction)` as visited to prevent infinite loops caused by revisiting the same edge of a hex.

`find_ring` reuses the same directional DFS to reconstruct a witness path when visualisation is needed.

## Bridge Detection

`check_bridge(board_mask, move)` determines whether the component returned by `bfs_reachable` includes stones on two distinct corners:

1. `get_all_corners(dim)` lists the six corner coordinates in the array system.
2. After BFS, count how many corners are present in the visited set.
3. Winning condition: at least two corners are connected to the trigger move.

`find_bridge` runs a DFS that stops as soon as it touches two different corners and records the path that connects them.

## Fork Detection

`check_fork(board_mask, move)` asks whether the component touches three distinct board edges (excluding corners):

1. `get_all_edges(dim)` produces six lists—one for each edge—containing every coordinate on that edge except the corners.
2. Using the BFS reachability set, test for each edge if any of its coordinates are present.
3. Winning condition: three or more edges are part of the connected component that contains `move`.

`find_fork` grows a DFS tree from the move, tracking which edges have already been touched. As soon as three unique edges are discovered it backtracks and returns every stone that participates in the fork.

## Combined Win Check

`check_win(board, move, player_num, path=None)` orchestrates the full win detection pipeline:

1. Convert the integer board into a boolean mask that marks the querying player’s stones.
2. Run `check_ring`. If it succeeds, optionally populate `path` with the loop returned by `find_ring`.
3. Otherwise invoke `check_fork_and_bridge`, which encapsulates the shared BFS. On success it distinguishes between a fork and a bridge and, if required, populates `path` through `find_fork` or `find_bridge`.

The function returns `(True, "ring"|"fork"|"bridge")` when a structure is found, and `(False, None)` otherwise. Because all three detections operate on the component generated by the latest move, the overall complexity stays linear in the size of that component rather than the whole board.
